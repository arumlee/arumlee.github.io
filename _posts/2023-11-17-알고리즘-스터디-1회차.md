---
published: true
layout: post
categories: blog
---

## 시간 복잡도 개념 익히기

### 1. 점근적 표기법의 개념 및 코딩테스트에서 실제로 적용하는 방법에 대해 정리해주세요.

사실 문제를 보자마자 점근적 표기법으로 성능 측정하기 글을 눌렀다가 _이전 포스팅에서는 시간 복잡도에 대해 알아봤습니다._ 라는 문구를 보고 바로 뒤로가기를 눌렀다.

점근적 표기법을 이해하기 위해서는 먼저 시간 복잡도에 대해 알아야한다.

1-1. 시간 복잡도는 무엇일까?

흔히 O(n) "빅-오 표기법"로 표기되는 시간 복잡도는 계산이론으로 해석하자면 **문제를 해결하는데 걸리는 시간과 입력의 함수 관계**를 가리킨다.

컴퓨터 과학에서는 **알고리즘의 시간복잡도는 입력을 나타내는 문자열 길이의 함수로서 작동하는 알고리즘을 취해 시간을 정량화하는 것** 이라고 한다.

알고리즘 문제를 풀면서 주로 2가지 정답 채점 기준을 만나게 된다. 바로 정확성 테스트와 수행시간(연산횟수) 테스트이다. 시간복잡도란 입력과 연산 수행시간의 상관관계(연산 횟수)에 따라 **성능을 측정**하는 척도이다.

1-2. 점근적 표기법이란 무엇일까?

앞서 시간복잡도가 공부했었던 이유는 내가 구현한 알고리즘 성능이 제한 시간내에 결과값을 낼 수 있는지 알아보려 공부했었다.

그런데 위키백과의 내용만 봐도 매우 복잡하다. 점근적 표기법은 **명확한 복잡도 대신, 성능을 가늠할 수 있도록 간략하게 복잡도를 표기한 것** 이다.

```python
def solution(n):
    count = 0
    # 반복문 1: n^2 연산 수행
    for i in range(n):
        for j in range(n):
            count += 1
    # 반복문 2: n번 연산 수행
    for k in range(n):
        count += 1
    # 반복문 3: 2n번 연산 수행
    for l in range(2*n):
        count += 1
    # 반복문 4: 5번 연산 수행
    for m in range(5):
        count += 1

    print(count) # 59 => n이 6일 때, 6^2 + 6 + 2*6 + 5 = 59

solution(6) # 함수 호출
```

위의 코드에 따르면 n이 6일 때 값이 59가 나온다.
그럼 이걸 N으로 치환하면, **N^2 + N + 2N +5 = N^2 + 3N + 5**가 된다.

이부분을 보고 이게 어떻게 간략하다는건지 이해는 못했지만, 알고리즘 테스트에서 테스트 케이스를 통과하려면 제한 시간 내에 코드가 결과값을 반환해야한다. 즉, '늦어도 제한 코드 내에 코드가 실행' 되어야 한다. 그 중에 제한 시간이 최악의 경우를 기반으로 한 알고리즘 성능을 **점근적 상한** 이라고 한다.

1-3. 점근적 상한

![photo_6278136319028869766_x.jpg](https://github.com/arumlee/arumlee.github.io/blob/main/_posts/photo_6278136319028869766_x.jpg?raw=true)

갑자기 그래프가 나와서 당황스럽지만, 대개 점근적 상한에 대한 설명을 그래프로 하길래 구글 검색으로 갖고와봤다.

위에 **N^2+3N+5** 라는 식을 다시 가져와서 그래프와 비교를 해보자면, N^2는 O(n^2), 3N은 O(3n), 5는 O(5)로 볼 수 있다.

이 n이 쭉 증가한다고 가정 했을때 O(n^2)는 아득히 위로 올라가고 있을테고 O(3n)는 O(n^2)보다는 아래지만 위로 올라가며, O(5)는 계속 일직선을 향해 갈 것이다.

이 때 가장 많은 영향을 끼치는 연산횟수는 위로 올라가고 있는 O(n^2)라고 볼 수 있고, 이를 제외한 나머지 O(3n)과 O(5)는 무시해도 상관없다.

그리고 위에 언급한 빅-오 표기법은 큰 상수 C를 곱해서 O(C\*n^2)라고 표시하게 된다.

### 2. 아래 다항식에 대해 점근적 상한을 정해주세요.

- Y = 2^X - 3X^2 + 5x

2^n - 3n^2 + 5n => O(2^n), O(3n^2), O(5n) => O(2^n) 예시: 부분집합 구하기, 하노이의 탑

- Y = X^2 + X! - 2^X

n^2 + n! - 2^n => O(n^2), O(n!), O(2^n) => O(n!) 예시: 외판원 문제 

- Y = 3X + log X - 4

3n + log n - 4 => O(3n), O(log n), O(4) => O(3n) / O(n) 예시: 순차탐색


### 3. 아래 문제를 읽고 점근적 상한을 구해주세요.

- 데이터가 N개인 배열을 순차 탐색하는 경우

데이터가 N개, 순차 탐색 -> O(N)

- 행과 열이 각각 N개인 행렬의 원소를 모두 탐색하는 경우

행과 열이 각각 N개, 모두 탐색 -> O(N^2)

- N개의 동전을 던질 때 앞/뒷면에 대한 모든 경우의 수

N개의 동전, 앞/뒷면(2가지 경우), 모든 경우 -> O(2^N)

### 4. 프로그래머스 문제

- [아이스 아메리카노](https://school.programmers.co.kr/learn/courses/30/lessons/120819)
- [중복된 숫자 개수](https://school.programmers.co.kr/learn/courses/30/lessons/120583)
- [팩토리얼](https://school.programmers.co.kr/learn/courses/30/lessons/120848)

## 5. 소감

스터디를 한다는 소식에 구글폼 신청을 했는데 계속 무소식이어서 저자님께 문의드렸더니 바로 오늘이 스터디 날이래서 부랴부랴 공부해서 올려보았다.

사실 프로그래머스 문제는 아직 안 풀어봤는데 이건 다음 스터디 전까진 꼭 풀어봐야겠다.

2, 3번 문제는 [점근적 표기법을 실제 코딩 테스트에 적용하기](https://cafe.naver.com/dremdeveloper/964) 참조해서 풀이했는데 이건 프로그래머스 문제 풀면서 내가 어떻게 풀었나 대입해보는 것도 나쁘지 않을 것 같다.

근데... O(3n)이 O(n)에 해당되는거 맞지.....? 맞을 것 같은데 왜이리 자신감이 없을까..

---

출처

1. 매일 알고리즘 카페 스터디 자료
2. [위키백과: 시간복잡도](https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84)

---

[매일 알고리즘 카페](https://cafe.naver.com/dremdeveloper/948) 코딩테스트 기초 스터디에서 스터디 중입니다.
